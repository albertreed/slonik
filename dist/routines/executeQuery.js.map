{"version":3,"sources":["../../src/routines/executeQuery.js"],"names":["TRANSACTION_ROLLBACK_ERROR_PREFIX","retryTransaction","connectionLogger","connection","transactionQueries","retryLimit","result","remainingRetries","attempt","query","transactionQuery","trace","queryId","executionContext","executionRoutine","sql","values","native","error","code","startsWith","clientConfiguration","rawSql","inheritedQueryId","slonik","terminated","BackendTerminatedError","trim","InvalidInputError","queryInputTime","process","hrtime","bigint","stackTrace","captureStackTrace","callSites","Error","stack","columnNumber","callSite","fileName","lineNumber","log","child","originalQuery","actualQuery","connectionId","poolId","sandbox","transactionId","interceptor","interceptors","beforeTransformQuery","transformQuery","beforeQueryExecution","info","notices","noticeListener","notice","push","on","transactionRetryLimit","message","includes","StatementTimeoutError","StatementCancelledError","NotNullIntegrityConstraintViolationError","constraint","ForeignKeyIntegrityConstraintViolationError","UniqueIntegrityConstraintViolationError","CheckIntegrityConstraintViolationError","off","queryExecutionError","UnexpectedStateError","afterQueryExecution","rows","transformRow","fields","row","beforeQueryResult"],"mappings":"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","sourcesContent":["// @flow\n\nimport { map } from \"inline-loops.macro\";\nimport { getStackTrace } from \"get-stack-trace\";\nimport { serializeError } from \"serialize-error\";\nimport { createQueryId, normaliseQueryValues } from \"../utilities\";\nimport {\n  BackendTerminatedError,\n  CheckIntegrityConstraintViolationError,\n  ForeignKeyIntegrityConstraintViolationError,\n  InvalidInputError,\n  NotNullIntegrityConstraintViolationError,\n  StatementCancelledError,\n  StatementTimeoutError,\n  UnexpectedStateError,\n  UniqueIntegrityConstraintViolationError,\n} from \"../errors\";\nimport type {\n  ClientConfigurationType,\n  InternalDatabaseConnectionType,\n  LoggerType,\n  PrimitiveValueExpressionType,\n  QueryContextType,\n  QueryIdType,\n  QueryResultRowType,\n  QueryType,\n} from \"../types\";\n\ntype ExecutionRoutineType = (\n  connection: InternalDatabaseConnectionType,\n  sql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  queryContext: QueryContextType,\n  query: QueryType\n) => Promise<*>;\n\ntype TransactionQueryType = {|\n  +executionContext: QueryContextType,\n  +executionRoutine: ExecutionRoutineType,\n  +sql: string,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n|};\n\n// @see https://www.postgresql.org/docs/current/errcodes-appendix.html\nconst TRANSACTION_ROLLBACK_ERROR_PREFIX = \"40\";\n\nconst retryTransaction = async (\n  connectionLogger: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  transactionQueries: $ReadOnlyArray<TransactionQueryType>,\n  retryLimit: number\n) => {\n  let result;\n  let remainingRetries = retryLimit;\n  let attempt = 0;\n\n  // @todo Provide information about the queries being retried to the logger.\n  while (remainingRetries-- > 0) {\n    attempt++;\n\n    try {\n      // @todo Respect SAVEPOINTs.\n      await connection.query(\"ROLLBACK\");\n      await connection.query(\"BEGIN\");\n\n      for (const transactionQuery of transactionQueries) {\n        connectionLogger.trace(\n          {\n            attempt,\n            queryId: transactionQuery.executionContext.queryId,\n          },\n          \"retrying query\"\n        );\n\n        result = await transactionQuery.executionRoutine(\n          connection,\n          transactionQuery.sql,\n          normaliseQueryValues(transactionQuery.values, connection.native),\n\n          // @todo Refresh execution context to reflect that the query has been re-tried.\n          // This (probably) requires changing `queryId` and `queryInputTime`.\n          // It should be needed only for the last query (because other queries will not be processed by the middlewares).\n          transactionQuery.executionContext,\n          {\n            sql: transactionQuery.sql,\n            values: transactionQuery.values,\n          }\n        );\n      }\n    } catch (error) {\n      if (\n        typeof error.code === \"string\" &&\n        error.code.startsWith(TRANSACTION_ROLLBACK_ERROR_PREFIX)\n      ) {\n        continue;\n      }\n\n      throw error;\n    }\n  }\n\n  return result;\n};\n\n// eslint-disable-next-line complexity\nexport default async (\n  connectionLogger: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  rawSql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  inheritedQueryId?: QueryIdType,\n  executionRoutine: ExecutionRoutineType\n) => {\n  if (connection.connection.slonik.terminated) {\n    throw new BackendTerminatedError(connection.connection.slonik.terminated);\n  }\n\n  if (rawSql.trim() === \"\") {\n    throw new InvalidInputError(\"Unexpected SQL input. Query cannot be empty.\");\n  }\n\n  if (rawSql.trim() === \"$1\") {\n    throw new InvalidInputError(\n      \"Unexpected SQL input. Query cannot be empty. Found only value binding.\"\n    );\n  }\n\n  const queryInputTime = process.hrtime.bigint();\n\n  let stackTrace = null;\n\n  if (clientConfiguration.captureStackTrace) {\n    const callSites = new Error().stack;\n\n    stackTrace = map(callSites, (callSite) => {\n      return {\n        columnNumber: callSite.columnNumber,\n        fileName: callSite.fileName,\n        lineNumber: callSite.lineNumber,\n      };\n    });\n  }\n\n  const queryId = inheritedQueryId || createQueryId();\n\n  const log = connectionLogger.child({\n    queryId,\n  });\n\n  const originalQuery = {\n    sql: rawSql,\n    values,\n  };\n\n  let actualQuery = {\n    ...originalQuery,\n  };\n\n  const executionContext: QueryContextType = {\n    connectionId: connection.connection.slonik.connectionId,\n    log,\n    originalQuery,\n    poolId: connection.connection.slonik.poolId,\n    queryId,\n    queryInputTime,\n    sandbox: {},\n    stackTrace,\n    transactionId: connection.connection.slonik.transactionId,\n  };\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforeTransformQuery) {\n      interceptor.beforeTransformQuery(executionContext, actualQuery);\n    }\n  }\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.transformQuery) {\n      actualQuery = interceptor.transformQuery(executionContext, actualQuery);\n    }\n  }\n\n  let result;\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforeQueryExecution) {\n      result = await interceptor.beforeQueryExecution(\n        executionContext,\n        actualQuery\n      );\n\n      if (result) {\n        log.info(\n          \"beforeQueryExecution interceptor produced a result; short-circuiting query execution using beforeQueryExecution result\"\n        );\n\n        return result;\n      }\n    }\n  }\n\n  const notices = [];\n\n  const noticeListener = (notice) => {\n    notices.push(notice);\n  };\n\n  connection.on(\"notice\", noticeListener);\n\n  try {\n    try {\n      try {\n        if (connection.connection.slonik.transactionQueries) {\n          connection.connection.slonik.transactionQueries.push({\n            executionContext,\n            executionRoutine,\n            sql: actualQuery.sql,\n            values: actualQuery.values,\n          });\n        }\n\n        result = await executionRoutine(\n          connection,\n          actualQuery.sql,\n          normaliseQueryValues(actualQuery.values, connection.native),\n          executionContext,\n          actualQuery\n        );\n      } catch (error) {\n        if (\n          typeof error.code === \"string\" &&\n          error.code.startsWith(TRANSACTION_ROLLBACK_ERROR_PREFIX) &&\n          clientConfiguration.transactionRetryLimit > 0\n        ) {\n          result = await retryTransaction(\n            connectionLogger,\n            connection,\n            connection.connection.slonik.transactionQueries,\n            clientConfiguration.transactionRetryLimit\n          );\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      log.error(\n        {\n          error: serializeError(error),\n        },\n        \"execution routine produced an error\"\n      );\n\n      // 'Connection terminated' refers to node-postgres error.\n      // @see https://github.com/brianc/node-postgres/blob/eb076db5d47a29c19d3212feac26cd7b6d257a95/lib/client.js#L199\n      if (error.code === \"57P01\" || error.message === \"Connection terminated\") {\n        connection.connection.slonik.terminated = error;\n\n        throw new BackendTerminatedError(error);\n      }\n\n      if (\n        error.code === \"57014\" &&\n        error.message.includes(\"canceling statement due to statement timeout\")\n      ) {\n        throw new StatementTimeoutError(error);\n      }\n\n      if (error.code === \"57014\") {\n        throw new StatementCancelledError(error);\n      }\n\n      if (error.code === \"23502\") {\n        throw new NotNullIntegrityConstraintViolationError(\n          error,\n          error.constraint\n        );\n      }\n\n      if (error.code === \"23503\") {\n        throw new ForeignKeyIntegrityConstraintViolationError(\n          error,\n          error.constraint\n        );\n      }\n\n      if (error.code === \"23505\") {\n        throw new UniqueIntegrityConstraintViolationError(\n          error,\n          error.constraint\n        );\n      }\n\n      if (error.code === \"23514\") {\n        throw new CheckIntegrityConstraintViolationError(\n          error,\n          error.constraint\n        );\n      }\n\n      throw error;\n    } finally {\n      connection.off(\"notice\", noticeListener);\n    }\n  } catch (error) {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.queryExecutionError) {\n        await interceptor.queryExecutionError(\n          executionContext,\n          actualQuery,\n          error\n        );\n      }\n    }\n\n    throw error;\n  }\n\n  if (!result) {\n    throw new UnexpectedStateError();\n  }\n\n  // $FlowFixMe\n  result.notices = notices;\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.afterQueryExecution) {\n      await interceptor.afterQueryExecution(\n        executionContext,\n        actualQuery,\n        result\n      );\n    }\n  }\n\n  // Stream does not have `rows` in the result object and all rows are already transformed.\n  if (result.rows) {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.transformRow) {\n        const transformRow = interceptor.transformRow;\n        const fields = result.fields;\n\n        // eslint-disable-next-line no-loop-func\n        const rows: $ReadOnlyArray<QueryResultRowType> = map(\n          result.rows,\n          (row) => {\n            return transformRow(executionContext, actualQuery, row, fields);\n          }\n        );\n\n        result = {\n          ...result,\n          rows,\n        };\n      }\n    }\n  }\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforeQueryResult) {\n      await interceptor.beforeQueryResult(\n        executionContext,\n        actualQuery,\n        result\n      );\n    }\n  }\n\n  return result;\n};\n"],"file":"executeQuery.js"}